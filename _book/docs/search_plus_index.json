{"./":{"url":"./","title":"Introduction","keywords":"","body":"LY-Note Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 19:25:45 "},"leetcode/":{"url":"leetcode/","title":"leetcode刷题本","keywords":"","body":"LeetCode刷题本 System.out.println(\"Hello World\"); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:04 "},"leetcode/shu-zu/":{"url":"leetcode/shu-zu/","title":"数组","keywords":"","body":"数组 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:00 "},"leetcode/shu-zu/jump-game.html":{"url":"leetcode/shu-zu/jump-game.html","title":"55.跳跃游戏","keywords":"","body":"55.跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 原题链接 解法1 动态规划 从前向后遍历，找到每个元素只跳一步的话，可达的最大位置。 如果前一个元素不可达到当前元素，则返回 Java代码class Solution { public boolean canJump(int[] nums) { int len=nums.length; int dp=nums[0]; for(int i=1;idp){ return false; } dp=Math.max(dp,nums[i]+i); } return true; } } 解法2 步步为营 从后向前遍历数组 判断当前位置能够到达终点，则将当前位置当作新的终点 只有遇到0时，才会发生不可达的事件 Java代码class Solution { public boolean canJump(int[] nums) { int len=nums.length; int n=0; for(int i=len-2;i>=0;i--){ if(nums[i]>n++){ n=0; } } return n==0; } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 20:27:42 "},"leetcode/lian-biao/":{"url":"leetcode/lian-biao/","title":"链表","keywords":"","body":"链表 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:02 "}}