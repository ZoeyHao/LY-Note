{"./":{"url":"./","title":"Introduction","keywords":"","body":"LY-Note Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 19:25:45 "},"leetcode/":{"url":"leetcode/","title":"leetcode刷题本","keywords":"","body":"LeetCode刷题本 System.out.println(\"Hello World\"); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:04 "},"leetcode/shu-zu/":{"url":"leetcode/shu-zu/","title":"数组","keywords":"","body":"数组 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:00 "},"leetcode/shu-zu/jump-game.html":{"url":"leetcode/shu-zu/jump-game.html","title":"55.跳跃游戏","keywords":"","body":"55.跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 原题链接 解法1 动态规划 从前向后遍历，找到每个元素只跳一步的话，可达的最大位置。 如果前一个元素不可达到当前元素，则返回 Java代码 class Solution { public boolean canJump(int[] nums) { int len=nums.length; int dp=nums[0]; for(int i=1;idp){ return false; } dp=Math.max(dp,nums[i]+i); } return true; } } 解法2 步步为营 从后向前遍历数组 判断当前位置能够到达终点，则将当前位置当作新的终点 只有遇到0时，才会发生不可达的事件 Java代码 class Solution { public boolean canJump(int[] nums) { int len=nums.length; int n=0; for(int i=len-2;i>=0;i--){ if(nums[i]>n++){ n=0; } } return n==0; } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 21:43:49 "},"leetcode/lian-biao/":{"url":"leetcode/lian-biao/","title":"链表","keywords":"","body":"链表 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:02 "},"leetcode/weekly-match/":{"url":"leetcode/weekly-match/","title":"周赛","keywords":"","body":"周赛 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 22:28:08 "},"leetcode/double-weekly-match/":{"url":"leetcode/double-weekly-match/","title":"双周赛","keywords":"","body":"双周赛 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 22:28:08 "},"leetcode/double-weekly-match/24.html":{"url":"leetcode/double-weekly-match/24.html","title":"第24场","keywords":"","body":"第24场双周赛 1.逐步求和得到正数的最小值 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 原题链接 方法1---暴力破解 求出逐步求和过程中，产生的最小值。 得出startVale，确保最小值可以大于1class Solution { public int minStartValue(int[] nums) { int len=nums.length; int min=nums[0]; int sum=0; for(int i=0;i 2.和为 K 的最少斐波那契数字数目 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。 斐波那契数字定义为： F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2 ， 其中 n > 2 。 数据保证对于给定的 k ，一定能找到可行解。 原题链接 方法1---暴力破解 算出所有小于K的斐波那契数字 从后往前遍历，用k去减，判断多少数字可以把k减光。class Solution { public int findMinFibonacciNumbers(int k) { int len=1; int[] arr=new int[10000]; arr[0]=0; arr[1]=1; while(arr[len]0&&k>0;i--){ if(k 3.长度为 n 的开心字符串中字典序第 k 小的字符串 一个 「开心字符串」定义为： 仅包含小写字母 ['a', 'b', 'c']. 对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。 比方说，字符串 \"abc\"，\"ac\"，\"b\" 和 \"abcbabcbcb\" 都是开心字符串，但是 \"aa\"，\"baa\" 和 \"ababbc\" 都不是开心字符串。 给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。 请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。 原题链接 方法1---DFS 递归方法进行DFS遍历 每当得到一个结果的时候需要k--，当k=0时无需继续遍历，直接返回结果 若最后k不为0，说明结果集数量小于k，所以返回空 class Solution { public String getHappyString(int n, int k) { StringBuilder sb=new StringBuilder(); k=func(' ',sb,n,k); if(k>0){ return \"\"; } return sb.toString(); } public int func(char last,StringBuilder sb,int n,int k){ if(n 4.恢复数组 某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。 给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。 按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。 由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。 原题链接 方法1---记忆化搜索 首先，很容易想到，通过DFS的方式一定可以获得解，只是有可能存在超时的问题。 试了一下，果然超时了，因为中间的过程存在大量的重复计算，我们是可以服用这些中间数据的，所以放到一个数组里存起来。 需要注意的一点是，由于k的上限非常大，直接用得到的整数与k去比较，整数可能会超出int的范围。这时要么将整数定义为long，要么将=把比较公式改一下，把常数项都移到k那边。 class Solution { public int numberOfArrays(String s, int k) { int[] n=new int[s.length()+1]; int res=func(s,0,k,n); return res; } public int func(String s,int l,int k,int[] arr){ if(l>=s.length()){ return 1; } if(s.charAt(l)=='0'){ return 0; } int n=0; int res=0; for(int i=l;iCopyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-19 13:08:10 "}}