{"./":{"url":"./","title":"Introduction","keywords":"","body":"LY-Note Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 19:25:45 "},"leetcode/":{"url":"leetcode/","title":"leetcode刷题本","keywords":"","body":"LeetCode刷题本 System.out.println(\"Hello World\"); Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:04 "},"leetcode/shu-zu/":{"url":"leetcode/shu-zu/","title":"数组","keywords":"","body":"数组 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:00 "},"leetcode/shu-zu/jump-game.html":{"url":"leetcode/shu-zu/jump-game.html","title":"55.跳跃游戏","keywords":"","body":"55.跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 原题链接 解法1 动态规划 从前向后遍历，找到每个元素只跳一步的话，可达的最大位置。 如果前一个元素不可达到当前元素，则返回 Java代码 class Solution { public boolean canJump(int[] nums) { int len=nums.length; int dp=nums[0]; for(int i=1;idp){ return false; } dp=Math.max(dp,nums[i]+i); } return true; } } 解法2 步步为营 从后向前遍历数组 判断当前位置能够到达终点，则将当前位置当作新的终点 只有遇到0时，才会发生不可达的事件 Java代码 class Solution { public boolean canJump(int[] nums) { int len=nums.length; int n=0; for(int i=len-2;i>=0;i--){ if(nums[i]>n++){ n=0; } } return n==0; } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 21:43:49 "},"leetcode/lian-biao/":{"url":"leetcode/lian-biao/","title":"链表","keywords":"","body":"链表 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 18:39:02 "},"leetcode/ju-zhen/":{"url":"leetcode/ju-zhen/","title":"矩阵","keywords":"","body":"矩阵 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 20:48:09 "},"leetcode/ju-zhen/number-of-Islands.html":{"url":"leetcode/ju-zhen/number-of-Islands.html","title":"200.岛屿数量","keywords":"","body":"200.岛屿数量 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 原题链接 方法1---BFS 遍历矩阵，如果当前位置为「1」，结果 + 1 对该位置进行 BFS 查询，并且把查询到的元素全都变为「0」。 class Solution { public int numIslands(char[][] grid) { int res=0; for(int i=0;i0 && grid[x-1][y]=='1'){ grid[x-1][y]='0'; bfs(x-1,y,grid); } if(x 0 && grid[x][y-1]=='1'){ grid[x][y-1]='0'; bfs(x,y-1,grid); } if(y Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 20:48:10 "},"leetcode/weekly-match/":{"url":"leetcode/weekly-match/","title":"周赛","keywords":"","body":"周赛 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 22:28:08 "},"leetcode/weekly-match/185.html":{"url":"leetcode/weekly-match/185.html","title":"第185场","keywords":"","body":"第185场周赛 1.逐步求和得到正数的最小值 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 原题链接 方法1---暴力破解 将字符串分别拆分成数字、字母的数组 然后根据数字、字母的数量整合成新的字符串class Solution { public String reformat(String s) { int len=s.length(); char[] arr1=new char[(len+1)/2]; char[] arr2=new char[(len+1)/2]; int l1=0,l2=0; for(int i=0;i='a'&&c='0'&&cl2&&l1-l2 2.点菜展示表 给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 原题链接 方法1---暴力破解 这道题考的是如何将一批输入的信息合理保存下来 首先将菜名保存到一个数组里，然后排序，在开头加上「Table」，然后保存到结果的第一行 将每桌点了什么菜放到map中，最后统计出每一桌分别点了每个菜多少次，然后把每桌的结果按顺序输出 由于桌号的范围在 1～500 以内，所以无需排序，用计数排序的思想去遍历它。 class Solution { public List> displayTable(List> orders) { List> res = new ArrayList>(); Set head = new HashSet(); int l2 = 0; Map> map = new HashMap(); for (int i = 0; i ()); } String s = orders.get(i).get(2); if (!head.contains(s)) { head.add(s); } map.get(table).add(s); } String[] row = new String[head.size()]; int rc=0; for (String s : head) { row[rc++]=s; } Arrays.sort(row); List rowList=new ArrayList(); rowList.add(\"Table\"); rowList.addAll(Arrays.asList(row)); res.add(rowList); for (int i = 0; i row2 = new ArrayList(); row2.add(i + \"\"); res.add(row2); List ss = map.get(i+\"\"); for(String item : res.get(0)) { int m = 0; if (item.equals(\"Table\")) { continue; } for (String item2 : ss) { if (item.equals(item2)) { m++; } } row2.add(m + \"\"); } } return res; } } Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-20 00:19:37 "},"leetcode/double-weekly-match/":{"url":"leetcode/double-weekly-match/","title":"双周赛","keywords":"","body":"双周赛 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-18 22:28:08 "},"leetcode/double-weekly-match/24.html":{"url":"leetcode/double-weekly-match/24.html","title":"第24场","keywords":"","body":"第24场双周赛 1.逐步求和得到正数的最小值 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 原题链接 方法1---暴力破解 求出逐步求和过程中，产生的最小值。 得出startVale，确保最小值可以大于1class Solution { public int minStartValue(int[] nums) { int len=nums.length; int min=nums[0]; int sum=0; for(int i=0;i 2.和为 K 的最少斐波那契数字数目 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。 斐波那契数字定义为： F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2 ， 其中 n > 2 。 数据保证对于给定的 k ，一定能找到可行解。 原题链接 方法1---暴力破解 算出所有小于K的斐波那契数字 从后往前遍历，用k去减，判断多少数字可以把k减光。class Solution { public int findMinFibonacciNumbers(int k) { int len=1; int[] arr=new int[10000]; arr[0]=0; arr[1]=1; while(arr[len]0&&k>0;i--){ if(k 3.长度为 n 的开心字符串中字典序第 k 小的字符串 一个 「开心字符串」定义为： 仅包含小写字母 ['a', 'b', 'c']. 对所有在 1 到 s.length - 1 之间的 i ，满足 s[i] != s[i + 1] （字符串的下标从 1 开始）。 比方说，字符串 \"abc\"，\"ac\"，\"b\" 和 \"abcbabcbcb\" 都是开心字符串，但是 \"aa\"，\"baa\" 和 \"ababbc\" 都不是开心字符串。 给你两个整数 n 和 k ，你需要将长度为 n 的所有开心字符串按字典序排序。 请你返回排序后的第 k 个开心字符串，如果长度为 n 的开心字符串少于 k 个，那么请你返回 空字符串 。 原题链接 方法1---DFS 递归方法进行DFS遍历 每当得到一个结果的时候需要k--，当k=0时无需继续遍历，直接返回结果 若最后k不为0，说明结果集数量小于k，所以返回空 class Solution { public String getHappyString(int n, int k) { StringBuilder sb=new StringBuilder(); k=func(' ',sb,n,k); if(k>0){ return \"\"; } return sb.toString(); } public int func(char last,StringBuilder sb,int n,int k){ if(n 4.恢复数组 某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 [1, k] 之间，且数组中的数字都没有前导 0 。 给你字符串 s 和整数 k 。可能会有多种不同的数组恢复结果。 按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。 由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。 原题链接 方法1---记忆化搜索 首先，很容易想到，通过DFS的方式一定可以获得解，只是有可能存在超时的问题。 试了一下，果然超时了，因为中间的过程存在大量的重复计算，我们是可以复用这些中间数据的，所以放到一个数组arr里存起来。 需要注意的一点是，由于k的上限非常大，直接用得到的整数与k去比较，整数可能会超出int的范围。这时要么将整数定义为long，要么把比较公式改一下，把常数项都移到k那边。 class Solution { public int numberOfArrays(String s, int k) { int[] arr=new int[s.length()+1]; int res=func(s,0,k,arr); return res; } public int func(String s,int l,int k,int[] arr){ if(l>=s.length()){ return 1; } if(s.charAt(l)=='0'){ return 0; } int n=0; int res=0; for(int i=l;iCopyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-04-19 13:15:01 "}}